---
title: "동적 계획법 기초"
date: 2025-05-11 17:13:00 +/-TTTT
categories: [Algorithm, Theory]
tags: [algorithm, theory, dynamic programming]
math: true
toc: true
---

동적 계획법(dynamic programming)이란 문제를 중복되는 하위 문제(subproblem)들로 나누고 메모이제이션(memoization)을 통해 해결하는 방법이다. 동적 계획법은 하위 문제의 수가 지수적으로 증가하는 경우에 유용하게 사용할 수 있다. 문제를 하위 문제들로 나눌 때 많이 중복되게 나눌수록 효과적으로 사용할 수 있다.

## 메모이제이션(Memoization)
메모이제이션은 각 하위 문제를 계산한 값을 저장하여 후에 동일한 하위 문제가 나왔을 때 저장한 값을 사용하는 기법이다. 함수의 반환 값이 함수의 입력 값만으로 결정되는 참조적 투명 함수(referential transparent function)의 경우에만 적용할 수 있다.
메모이제이션은 보통 값을 배열에 저장하는데, 배열의 인덱스에 하위 문제의 상태를 이용한다. 따라서 하위 문제의 수가 적을수록 메모리를 적게 사용한다.

## 최적 부분 구조(Optimal substructure)
최적 부분 구조는 문제와 분할 방식에 성립하는 조건으로, 각 부분 문제의 최적해로부터 전체 문제의 최적해를 얻을 수 있을 경우 최적 부분 구조가 성립한다. 최적 부분 구조가 성립할 경우 메모이제이션에 현재 부분 문제의 상태만 이용하여 답을 저장할 수 있게 되므로 사용하는 메모리의 크기가 줄고, 수행 시간이 빨라진다.

## 경우의 수
동적 계획법은 경우의 수를 구하는 문제에도 사용될 수 있는데, 경우의 수를 구할 때 각 부분 문제에서 사용하는 선택지들에 다음과 같은 속성이 성립해야 한다.
- 모든 경우는 이 선택지들에 포함됨
- 어떤 경우도 두 개 이상의 선택지에 포함되지 않음

## 알고리즘 진행 과정

### 1. 완전 탐색 알고리즘 설계
주어진 문제를 완전 탐색으로 해결하는 알고리즘을 설계한다.

### 2. 부분 문제 수정
부분 문제의 입력에 이전에 선택한 정보가 있으면 필요한 것만 남기고 최대한 지운다. 최적 부분 구조가 성립하면 이전에 선택한 정보를 전부 지울 수 있다. 부분 문제가 앞으로 남은 선택들에 대한 답을 구하도록 수정한다.

### 3. 입력 수정
입력이 정수가 아니라 배열이나 문자열일 경우 적절한 변환을 통해 메모이제이션할 수 있게 한다.

### 4. 메모이제이션 적용
수정된 정보를 바탕으로 메모이제이션을 적용한다.

## 의사 코드
```
memo = empty map or table

function dp(x, y, ...):
    if base case is met:
        return result

    if memo[x][y] exists:
        return memo[x][y]

    result = compute_using(dp(smaller_subproblems))
    memo[x][y] = result

    return result
```